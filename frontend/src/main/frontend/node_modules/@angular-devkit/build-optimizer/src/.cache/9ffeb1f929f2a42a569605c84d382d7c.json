{"remainingRequest":"C:\\Work_edu_dp\\complexnet\\frontend\\src\\main\\frontend\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!C:\\Work_edu_dp\\complexnet\\frontend\\src\\main\\frontend\\node_modules\\angular-in-memory-web-api\\in-memory-backend.service.js","dependencies":[{"path":"C:\\Work_edu_dp\\complexnet\\frontend\\src\\main\\frontend\\node_modules\\angular-in-memory-web-api\\in-memory-backend.service.js","mtime":1522179277099},{"path":"C:\\Work_edu_dp\\complexnet\\frontend\\src\\main\\frontend\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1522167641633},{"path":"C:\\Work_edu_dp\\complexnet\\frontend\\src\\main\\frontend\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1522167645651}],"contextDependencies":[],"result":["import { Inject, Injectable, Injector, Optional } from '@angular/core';\nimport { BaseResponseOptions, BrowserXhr, Headers, ReadyState, RequestMethod, Response, ResponseOptions, URLSearchParams, XHRBackend, XSRFStrategy } from '@angular/http';\nimport { Observable } from 'rxjs/Observable';\nimport 'rxjs/add/operator/delay';\nimport { STATUS, STATUS_CODE_INFO } from './http-status-codes';\n////////////  HELPERS ///////////\n/**\n * Create an error Response from an HTTP status code and error message\n */\nexport function createErrorResponse(req, status, message) {\n    return new ResponseOptions({\n        body: { 'error': \"\" + message },\n        url: req.url,\n        headers: new Headers({ 'Content-Type': 'application/json' }),\n        status: status\n    });\n}\n/**\n * Create an Observable response from response options.\n */\nexport function createObservableResponse(req, resOptions) {\n    return new Observable(function (responseObserver) {\n        emitResponse(responseObserver, req, resOptions);\n        return function () { }; // unsubscribe function\n    });\n}\n/**\n * Create a response from response options\n * and tell \"ResponseObserver\" (an `Observer<Response>`) to emit it.\n * The observer's observable is either completed or in error state after call.\n */\nexport function emitResponse(responseObserver, req, resOptions) {\n    resOptions.url = resOptions.url || req.url; // make sure url is set\n    resOptions = setStatusText(resOptions);\n    var res = new Response(resOptions);\n    if (isSuccess(res.status)) {\n        responseObserver.next(res);\n        responseObserver.complete();\n    }\n    else {\n        responseObserver.error(res);\n    }\n}\n/**\n* Interface for a class that creates an in-memory database\n*\n* Its `createDb` method creates a hash of named collections that represents the database\n*\n* For maximum flexibility, the service may define HTTP method overrides.\n* Such methods must match the spelling of an HTTP method in lower case (e.g, \"get\").\n* If a request has a matching method, it will be called as in\n* `get(info: requestInfo, db: {})` where `db` is the database object described above.\n*/\nexport var InMemoryDbService = /*@__PURE__*/ (function () {\n    function InMemoryDbService() {\n    }\n    return InMemoryDbService;\n}());\n/**\n* Interface for InMemoryBackend configuration options\n*/\nexport var InMemoryBackendConfigArgs = /*@__PURE__*/ (function () {\n    function InMemoryBackendConfigArgs() {\n    }\n    return InMemoryBackendConfigArgs;\n}());\nexport function removeTrailingSlash(path) {\n    return path.replace(/\\/$/, '');\n}\n/////////////////////////////////\n/**\n*  InMemoryBackendService configuration options\n*  Usage:\n*    InMemoryWebApiModule.forRoot(InMemHeroService, {delay: 600})\n*\n*  or if providing separately:\n*    provide(InMemoryBackendConfig, {useValue: {delay: 600}}),\n*/\nexport var InMemoryBackendConfig = /*@__PURE__*/ (function () {\n    function InMemoryBackendConfig(config) {\n        if (config === void 0) {\n            config = {};\n        }\n        Object.assign(this, {\n            // default config:\n            caseSensitiveSearch: false,\n            defaultResponseOptions: new BaseResponseOptions(),\n            delay: 500,\n            delete404: false,\n            passThruUnknownUrl: false,\n            post204: true,\n            put204: true,\n            apiBase: undefined,\n            host: undefined,\n            rootPath: undefined // default value is actually set in InMemoryBackendService ctor\n        }, config);\n    }\n    return InMemoryBackendConfig;\n}());\n/**\n * Returns true if the the Http Status Code is 200-299 (success)\n */\nexport function isSuccess(status) { return status >= 200 && status < 300; }\n;\n/**\n * Set the status text in a response:\n */\nexport function setStatusText(options) {\n    try {\n        var statusCode = STATUS_CODE_INFO[options.status];\n        options['statusText'] = statusCode ? statusCode.text : 'Unknown Status';\n        return options;\n    }\n    catch (err) {\n        return new ResponseOptions({\n            status: STATUS.INTERNAL_SERVER_ERROR,\n            statusText: 'Invalid Server Operation'\n        });\n    }\n}\n////////////  InMemoryBackendService ///////////\n/**\n * Simulate the behavior of a RESTy web api\n * backed by the simple in-memory data store provided by the injected InMemoryDataService service.\n * Conforms mostly to behavior described here:\n * http://www.restapitutorial.com/lessons/httpmethods.html\n *\n * ### Usage\n *\n * Create `InMemoryDataService` class that implements `InMemoryDataService`.\n * Call `forRoot` static method with this service class and optional configuration object:\n * ```\n * // other imports\n * import { HttpModule }           from '@angular/http';\n * import { InMemoryWebApiModule } from 'angular-in-memory-web-api';\n *\n * import { InMemHeroService, inMemConfig } from '../api/in-memory-hero.service';\n * @NgModule({\n *  imports: [\n *    HttpModule,\n *    InMemoryWebApiModule.forRoot(InMemHeroService, inMemConfig),\n *    ...\n *  ],\n *  ...\n * })\n * export class AppModule { ... }\n * ```\n */\nexport var InMemoryBackendService = /*@__PURE__*/ (function () {\n    function InMemoryBackendService(injector, inMemDbService, config) {\n        this.injector = injector;\n        this.inMemDbService = inMemDbService;\n        this.config = new InMemoryBackendConfig();\n        this.resetDb();\n        var loc = this.getLocation('/');\n        this.config.host = loc.host; // default to app web server host\n        this.config.rootPath = loc.pathname; // default to path when app is served (e.g.'/')\n        Object.assign(this.config, config || {});\n        this.setPassThruBackend();\n    }\n    InMemoryBackendService.prototype.createConnection = function (req) {\n        var response;\n        try {\n            response = this.handleRequest(req);\n        }\n        catch (error) {\n            var err = error.message || error;\n            var options = createErrorResponse(req, STATUS.INTERNAL_SERVER_ERROR, \"\" + err);\n            response = this.addDelay(createObservableResponse(req, options));\n        }\n        return {\n            readyState: ReadyState.Done,\n            request: req,\n            response: response\n        };\n    };\n    ////  protected /////\n    /**\n     * Process Request and return an Observable of Http Response object\n     * in the manner of a RESTy web api.\n     *\n     * Expect URI pattern in the form :base/:collectionName/:id?\n     * Examples:\n     *   // for store with a 'customers' collection\n     *   GET api/customers          // all customers\n     *   GET api/customers/42       // the character with id=42\n     *   GET api/customers?name=^j  // 'j' is a regex; returns customers whose name starts with 'j' or 'J'\n     *   GET api/customers.json/42  // ignores the \".json\"\n     *\n     * Also accepts direct commands to the service in which the last segment of the apiBase is the word \"commands\"\n     * Examples:\n     *     POST commands/resetDb,\n     *     GET/POST commands/config - get or (re)set the config\n     *\n     *   HTTP overrides:\n     *     If the injected inMemDbService defines an HTTP method (lowercase)\n     *     The request is forwarded to that method as in\n     *     `inMemDbService.get(httpMethodInterceptorArgs)`\n     *     which must return an `Observable<Response>`\n     */\n    InMemoryBackendService.prototype.handleRequest = function (req) {\n        var parsed = this.inMemDbService['parseUrl'] ?\n            // parse with override method\n            this.inMemDbService['parseUrl'](req.url) :\n            // parse with default url parser\n            this.parseUrl(req.url);\n        var base = parsed.base, collectionName = parsed.collectionName, id = parsed.id, query = parsed.query, resourceUrl = parsed.resourceUrl;\n        var collection = this.db[collectionName];\n        var reqInfo = {\n            req: req,\n            base: base,\n            collection: collection,\n            collectionName: collectionName,\n            headers: new Headers({ 'Content-Type': 'application/json' }),\n            id: this.parseId(collection, id),\n            query: query,\n            resourceUrl: resourceUrl\n        };\n        var reqMethodName = RequestMethod[req.method || 0].toLowerCase();\n        var resOptions;\n        if (/commands\\/$/i.test(reqInfo.base)) {\n            return this.commands(reqInfo);\n        }\n        else if (this.inMemDbService[reqMethodName]) {\n            // InMemoryDbService has an overriding interceptor for this HTTP method; call it\n            // The interceptor result must be an Observable<Response>\n            var interceptorArgs = {\n                requestInfo: reqInfo,\n                db: this.db,\n                config: this.config,\n                passThruBackend: this.passThruBackend\n            };\n            var interceptorResponse = this.inMemDbService[reqMethodName](interceptorArgs);\n            return this.addDelay(interceptorResponse);\n        }\n        else if (reqInfo.collection) {\n            // request is for a collection created by the InMemoryDbService\n            return this.addDelay(this.collectionHandler(reqInfo));\n        }\n        else if (this.passThruBackend) {\n            // Passes request thru to a \"real\" backend which returns an Observable<Response>\n            // BAIL OUT with this Observable<Response>\n            return this.passThruBackend.createConnection(req).response;\n        }\n        else {\n            // can't handle this request\n            resOptions = createErrorResponse(req, STATUS.NOT_FOUND, \"Collection '\" + collectionName + \"' not found\");\n            return this.addDelay(createObservableResponse(req, resOptions));\n        }\n    };\n    /**\n     * Add configured delay to response observable unless delay === 0\n     */\n    InMemoryBackendService.prototype.addDelay = function (response) {\n        var delay = this.config.delay;\n        return delay === 0 ? response : response.delay(delay || 500);\n    };\n    /**\n     * Apply query/search parameters as a filter over the collection\n     * This impl only supports RegExp queries on string properties of the collection\n     * ANDs the conditions together\n     */\n    InMemoryBackendService.prototype.applyQuery = function (collection, query) {\n        // extract filtering conditions - {propertyName, RegExps) - from query/search parameters\n        var conditions = [];\n        var caseSensitive = this.config.caseSensitiveSearch ? undefined : 'i';\n        query.paramsMap.forEach(function (value, name) {\n            value.forEach(function (v) { return conditions.push({ name: name, rx: new RegExp(decodeURI(v), caseSensitive) }); });\n        });\n        var len = conditions.length;\n        if (!len) {\n            return collection;\n        }\n        // AND the RegExp conditions\n        return collection.filter(function (row) {\n            var ok = true;\n            var i = len;\n            while (ok && i) {\n                i -= 1;\n                var cond = conditions[i];\n                ok = cond.rx.test(row[cond.name]);\n            }\n            return ok;\n        });\n    };\n    InMemoryBackendService.prototype.clone = function (data) {\n        return JSON.parse(JSON.stringify(data));\n    };\n    InMemoryBackendService.prototype.collectionHandler = function (reqInfo) {\n        var _this = this;\n        var req = reqInfo.req;\n        return new Observable(function (responseObserver) {\n            var resOptions;\n            switch (req.method) {\n                case RequestMethod.Get:\n                    resOptions = _this.get(reqInfo);\n                    break;\n                case RequestMethod.Post:\n                    resOptions = _this.post(reqInfo);\n                    break;\n                case RequestMethod.Put:\n                    resOptions = _this.put(reqInfo);\n                    break;\n                case RequestMethod.Delete:\n                    resOptions = _this.delete(reqInfo);\n                    break;\n                default:\n                    resOptions = createErrorResponse(req, STATUS.METHOD_NOT_ALLOWED, 'Method not allowed');\n                    break;\n            }\n            // If `inMemDbService.responseInterceptor` exists, let it morph the response options\n            if (_this.inMemDbService['responseInterceptor']) {\n                resOptions = _this.inMemDbService['responseInterceptor'](resOptions, reqInfo);\n            }\n            emitResponse(responseObserver, reqInfo.req, resOptions);\n            return function () { }; // unsubscribe function\n        });\n    };\n    /**\n     * When the last segment of the `base` path is \"commands\", the `collectionName` is the command\n     * Example URLs:\n     *   commands/resetdb   // Reset the \"database\" to its original state\n     *   commands/config (GET) // Return this service's config object\n     *   commands/config (!GET) // Update the config (e.g. delay)\n     *\n     * Commands are \"hot\", meaning they are always executed immediately\n     * whether or not someone subscribes to the returned observable\n     *\n     * Usage:\n     *   http.post('commands/resetdb', undefined);\n     *   http.get('commands/config');\n     *   http.post('commands/config', '{\"delay\":1000}');\n     */\n    InMemoryBackendService.prototype.commands = function (reqInfo) {\n        var command = reqInfo.collectionName.toLowerCase();\n        var method = reqInfo.req.method;\n        var resOptions;\n        switch (command) {\n            case 'resetdb':\n                this.resetDb();\n                resOptions = new ResponseOptions({ status: STATUS.OK });\n                break;\n            case 'config':\n                if (method === RequestMethod.Get) {\n                    resOptions = new ResponseOptions({\n                        body: this.clone(this.config),\n                        status: STATUS.OK\n                    });\n                }\n                else {\n                    // Be nice ... any other method is a config update\n                    var body = JSON.parse(reqInfo.req.text() || '{}');\n                    Object.assign(this.config, body);\n                    this.setPassThruBackend();\n                    resOptions = new ResponseOptions({ status: STATUS.NO_CONTENT });\n                }\n                break;\n            default:\n                resOptions = createErrorResponse(reqInfo.req, STATUS.INTERNAL_SERVER_ERROR, \"Unknown command \\\"\" + command + \"\\\"\");\n        }\n        return createObservableResponse(reqInfo.req, resOptions);\n    };\n    InMemoryBackendService.prototype.delete = function (_a) {\n        var id = _a.id, collection = _a.collection, collectionName = _a.collectionName, headers = _a.headers, req = _a.req;\n        // tslint:disable-next-line:triple-equals\n        if (id == undefined) {\n            return createErrorResponse(req, STATUS.NOT_FOUND, \"Missing \\\"\" + collectionName + \"\\\" id\");\n        }\n        var exists = this.removeById(collection, id);\n        return new ResponseOptions({\n            headers: headers,\n            status: (exists || !this.config.delete404) ? STATUS.NO_CONTENT : STATUS.NOT_FOUND\n        });\n    };\n    InMemoryBackendService.prototype.findById = function (collection, id) {\n        return collection.find(function (item) { return item.id === id; });\n    };\n    InMemoryBackendService.prototype.genId = function (collection) {\n        // assumes numeric ids\n        var maxId = 0;\n        collection.reduce(function (prev, item) {\n            maxId = Math.max(maxId, typeof item.id === 'number' ? item.id : maxId);\n        }, undefined);\n        return maxId + 1;\n    };\n    InMemoryBackendService.prototype.get = function (_a) {\n        var id = _a.id, query = _a.query, collection = _a.collection, collectionName = _a.collectionName, headers = _a.headers, req = _a.req;\n        var data = collection;\n        // tslint:disable-next-line:triple-equals\n        if (id != undefined && id !== '') {\n            data = this.findById(collection, id);\n        }\n        else if (query) {\n            data = this.applyQuery(collection, query);\n        }\n        if (!data) {\n            return createErrorResponse(req, STATUS.NOT_FOUND, \"'\" + collectionName + \"' with id='\" + id + \"' not found\");\n        }\n        return new ResponseOptions({\n            body: { data: this.clone(data) },\n            headers: headers,\n            status: STATUS.OK\n        });\n    };\n    InMemoryBackendService.prototype.getLocation = function (href) {\n        if (!href.startsWith('http')) {\n            // get the document iff running in browser\n            var doc = (typeof document === 'undefined') ? undefined : document;\n            // add host info to url before parsing.  Use a fake host when not in browser.\n            var base = doc ? doc.location.protocol + '//' + doc.location.host : 'http://fake';\n            href = href.startsWith('/') ? base + href : base + '/' + href;\n        }\n        var uri = this.parseuri(href);\n        var loc = {\n            host: uri.host,\n            protocol: uri.protocol,\n            port: uri.port,\n            pathname: uri.path,\n            search: uri.query ? '?' + uri.query : ''\n        };\n        return loc;\n    };\n    ;\n    // Adapted from parseuri package - http://blog.stevenlevithan.com/archives/parseuri\n    InMemoryBackendService.prototype.parseuri = function (str) {\n        // tslint:disable-next-line:max-line-length\n        var URL_REGEX = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n        var key = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port',\n            'relative', 'path', 'directory', 'file', 'query', 'anchor'];\n        var m = URL_REGEX.exec(str);\n        var uri = {};\n        var i = 14;\n        while (i--) {\n            uri[key[i]] = m[i] || '';\n        }\n        return uri;\n    };\n    InMemoryBackendService.prototype.indexOf = function (collection, id) {\n        return collection.findIndex(function (item) { return item.id === id; });\n    };\n    // tries to parse id as number if collection item.id is a number.\n    // returns the original param id otherwise.\n    InMemoryBackendService.prototype.parseId = function (collection, id) {\n        // tslint:disable-next-line:triple-equals\n        if (!collection || id == undefined) {\n            return undefined;\n        }\n        var isNumberId = collection[0] && typeof collection[0].id === 'number';\n        if (isNumberId) {\n            var idNum = parseFloat(id);\n            return isNaN(idNum) ? id : idNum;\n        }\n        return id;\n    };\n    /**\n     * Parses the request URL into a `ParsedUrl` object.\n     * Parsing depends upon certain values of `config`: `apiBase`, `host`, and `urlRoot`.\n     *\n     * Configuring the `apiBase` yields the most interesting changes to `parseUrl` behavior:\n     *   When apiBase=undefined and url='http://localhost/api/collection/42'\n     *     {base: 'api/', collectionName: 'collection', id: '42', ...}\n     *   When apiBase='some/api/root/' and url='http://localhost/some/api/root/collection'\n     *     {base: 'some/api/root/', collectionName: 'collection', id: undefined, ...}\n     *   When apiBase='/' and url='http://localhost/collection'\n     *     {base: '/', collectionName: 'collection', id: undefined, ...}\n     *\n     * The actual api base segment values are ignored. Only the number of segments matters.\n     * The following api base strings are considered identical: 'a/b' ~ 'some/api/' ~ `two/segments'\n     *\n     * To replace this default method, assign your alternative to your InMemDbService['parseUrl']\n     */\n    InMemoryBackendService.prototype.parseUrl = function (url) {\n        try {\n            var loc = this.getLocation(url);\n            var drop = this.config.rootPath.length;\n            var urlRoot = '';\n            if (loc.host !== this.config.host) {\n                // url for a server on a different host!\n                // assume it's collection is actually here too.\n                drop = 1; // the leading slash\n                urlRoot = loc.protocol + '//' + loc.host + '/';\n            }\n            var path = loc.pathname.substring(drop);\n            var pathSegments = path.split('/');\n            var segmentIx = 0;\n            // apiBase: the front part of the path devoted to getting to the api route\n            // Assumes first path segment if no config.apiBase\n            // else ignores as many path segments as are in config.apiBase\n            // Does NOT care what the api base chars actually are.\n            var apiBase = void 0;\n            // tslint:disable-next-line:triple-equals\n            if (this.config.apiBase == undefined) {\n                apiBase = pathSegments[segmentIx++];\n            }\n            else {\n                apiBase = removeTrailingSlash(this.config.apiBase.trim());\n                if (apiBase) {\n                    segmentIx = apiBase.split('/').length;\n                }\n                else {\n                    segmentIx = 0; // no api base at all; unwise but allowed.\n                }\n            }\n            apiBase = apiBase + '/';\n            var collectionName = pathSegments[segmentIx++];\n            // ignore anything after a '.' (e.g.,the \"json\" in \"customers.json\")\n            collectionName = collectionName && collectionName.split('.')[0];\n            var id = pathSegments[segmentIx++];\n            var query = loc.search && new URLSearchParams(loc.search.substr(1));\n            var resourceUrl = urlRoot + apiBase + collectionName + '/';\n            return { base: apiBase, collectionName: collectionName, id: id, query: query, resourceUrl: resourceUrl };\n        }\n        catch (err) {\n            var msg = \"unable to parse url '\" + url + \"'; original error: \" + err.message;\n            throw new Error(msg);\n        }\n    };\n    InMemoryBackendService.prototype.post = function (_a) {\n        var collection = _a.collection, headers = _a.headers, id = _a.id, req = _a.req, resourceUrl = _a.resourceUrl;\n        var item = JSON.parse(req.text());\n        // tslint:disable-next-line:triple-equals\n        if (item.id == undefined) {\n            item.id = id || this.genId(collection);\n        }\n        // ignore the request id, if any. Alternatively,\n        // could reject request if id differs from item.id\n        id = item.id;\n        var existingIx = this.indexOf(collection, id);\n        var body = { data: this.clone(item) };\n        if (existingIx > -1) {\n            collection[existingIx] = item;\n            var res = this.config.post204 ?\n                { headers: headers, status: STATUS.NO_CONTENT } :\n                { headers: headers, body: body, status: STATUS.OK }; // successful; return entity\n            return new ResponseOptions(res);\n        }\n        else {\n            collection.push(item);\n            headers.set('Location', resourceUrl + '/' + id);\n            return new ResponseOptions({ headers: headers, body: body, status: STATUS.CREATED });\n        }\n    };\n    InMemoryBackendService.prototype.put = function (_a) {\n        var id = _a.id, collection = _a.collection, collectionName = _a.collectionName, headers = _a.headers, req = _a.req;\n        var item = JSON.parse(req.text());\n        // tslint:disable-next-line:triple-equals\n        if (item.id == undefined) {\n            return createErrorResponse(req, STATUS.NOT_FOUND, \"Missing '\" + collectionName + \"' id\");\n        }\n        // tslint:disable-next-line:triple-equals\n        if (id != item.id) {\n            return createErrorResponse(req, STATUS.BAD_REQUEST, \"\\\"\" + collectionName + \"\\\" id does not match item.id\");\n        }\n        var existingIx = this.indexOf(collection, id);\n        var body = { data: this.clone(item) };\n        if (existingIx > -1) {\n            collection[existingIx] = item;\n            var res = this.config.put204 ?\n                { headers: headers, status: STATUS.NO_CONTENT } :\n                { headers: headers, body: body, status: STATUS.OK }; // successful; return entity\n            return new ResponseOptions(res);\n        }\n        else {\n            collection.push(item);\n            return new ResponseOptions({ headers: headers, body: body, status: STATUS.CREATED });\n        }\n    };\n    InMemoryBackendService.prototype.removeById = function (collection, id) {\n        var ix = this.indexOf(collection, id);\n        if (ix > -1) {\n            collection.splice(ix, 1);\n            return true;\n        }\n        return false;\n    };\n    /**\n     * Reset the \"database\" to its original state\n     */\n    InMemoryBackendService.prototype.resetDb = function () {\n        this.db = this.inMemDbService.createDb();\n    };\n    InMemoryBackendService.prototype.setPassThruBackend = function () {\n        this.passThruBackend = undefined;\n        if (this.config.passThruUnknownUrl) {\n            try {\n                // copied from @angular/http/backends/xhr_backend\n                var browserXhr = this.injector.get(BrowserXhr);\n                var baseResponseOptions = this.injector.get(ResponseOptions);\n                var xsrfStrategy = this.injector.get(XSRFStrategy);\n                this.passThruBackend = new XHRBackend(browserXhr, baseResponseOptions, xsrfStrategy);\n            }\n            catch (ex) {\n                ex.message = 'Cannot create passThru404 backend; ' + (ex.message || '');\n                throw ex;\n            }\n        }\n    };\n    return InMemoryBackendService;\n}());\n//# sourceMappingURL=in-memory-backend.service.js.map \n",null]}